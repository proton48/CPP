#include "headers.h"
// ОПРЕДЕЛЕНИЯ ДЛЯ КЛАССА Snack

Snack::Snack(string imya)				//конструктор снэка
{
	name = imya;
}

Snack::Snack()							//конструктор по умолчанию
{
	name = "No";						//пишем значение No, по умолчанию создаем конструктор пустышку.
}

Snack::~Snack()							//деструктор
{

}
string Snack::getName()					//геттер, возвращает имя снека
{
	return name;
}

//ОПРЕДЕЛЕНИЯ ДЛЯ КЛАССА Snackslot

SnackSlot::SnackSlot()		//конструктор по умолчанию			
{
	qty = 1;				//по умолчанию создаем слот с одной ячейкой под снэк
	snack = new Snack();	//и в ней же создаем пустой снэк
	isadd = false;			//фла добавления в вендинговую машину, для слота по умолчанию FALSE 
}



SnackSlot::SnackSlot(int x)		//конструктор с указанием количества ячеек под снеки
{								
	qty = x;					//количество ячеек	
	snack = new Snack[qty];		//создаем новый массив снэков, по умолчанию вызывается конструктор по умолчанию для каждого снека в массиве
	isadd = false;				//флаг добавления слота в вендинговую машину
}

SnackSlot::~SnackSlot()			//деструктор
{

}

bool SnackSlot::getisadd()		//геттер, возвращает флаг добавления слота в вендинговую машину
{
	return isadd;
}

void SnackSlot::setisadd(bool val) //сеттер, меняет значение флага добавления слота в вендинговую машину
{
	isadd = val;
}


void SnackSlot::addSnack(Snack *sn)			//функция добавления снека в слот	
{
	Snack* tmp = new Snack;					//создаем временную переменную типа снэк
	tmp = snack;							//присваиваем значение указателя на первый ээлемент массива снэков в слоте
	for (int i = 0; i < qty; i++)			//далее циклом пробегаем ячейки для снеков и ищем пустую
	{
		if (snack->getName() == "No")		//проверка, пустая ли ячейка
		{
			*snack = Snack(*sn);			//проваливаемся сюда, если ячейка пустая и и снеку присваиваем значение добавляемого снека
			break;							//прерываем цикл for
		}
		else
		{
			snack++;						//если ячейка заполнена, то указатель на элемент массива увеличиваем
		}
	}
	snack = tmp;							//когда весь код выше отработал, меняем указатель snack обратно, на указатель на первый элемент массива снэков
}

void SnackSlot::showSlot()					//функция, выводит на консоль все ячейки под снеки в слоте и чем они заняты
{
	Snack* tmp = new Snack;					//создаем временный указаетль 
	tmp = snack;							//и пишем туда значение указателя на первый элемент массива снэков в слоте
	for (int i = 0; i < qty; i++)			//пробегаем все снеки циклом
	{
		cout << snack->getName() << " ";	//выводим на консоль имя снэка в слоте, вызывая снэка имя геттером
		++snack;							//меняем указатель на следующую ячейку в слоте
	}
	tmp = snack;							//когда весь слот пробежали циклом, возвращаем указатель обратно на указатель на первый элемент массива.
}

//ОПРЕДЕЛЕНИЯ ДЛЯ КЛАССА VendingMachine


VendingMachine::VendingMachine(int x)		//Конструктор, принимает на вход значение количества мест под слот в машине
{
	qty = x;								//количество слотов
	snackslot.reserve(qty);					//резервируем место под слоты
	SnackSlot* noslot = new SnackSlot();	//создаем слот пустышку
	for (int i = 0; i < qty; i++)			//дальше в цикле загружаем в машину слот пустышку.
	{
		snackslot.push_back(*noslot);		
	}
	
	
}

void VendingMachine::addSlot(SnackSlot* sl)				//функция добавления слота в машину на вход принимает указатель на слот
{
	if (sl->getisadd() == true)							//проверяем не добавлен ли добавляемый слот в машину, проверка чтобы не загрузить один слот 2 раза
	{
		cout << "слот уже добавлен в машину" << endl;
	}
	if (getEmptySlotsCount() == 0)						//проверяем есть ли свободные места под слоты в машине
	{
		cout << "Нет свободных мест для слота" << endl;
	}
	if (snackslot.at(0).getisadd() == false)			//проверяем, что первый элемент массива слотов - слот пустышка с флагом добавления false
	{
		snackslot.erase(snackslot.begin());				//стираем слот 1элемент массива - слот пустышку
	}
	sl->setisadd(true);									//у добавляемого слота меняем флаг добавления в машину на true
	snackslot.push_back(*sl);							//загружаем слот с конца в массив слотов в машину
	snackslot.shrink_to_fit();							//подрезаем массив
}
void VendingMachine::removeSlot()						//фнукция удаления слота из машины (вынимает только последний загруженный слот)
{
	
	if (getEmptySlotsCount() == qty)					//проверяем, не пустая ли машина
	{
		cout << "Все слоты свободны" << endl;
	}
	if (snackslot.at(qty-1).getisadd() == true)			//проверяем, что последний слот в машине
	{
		snackslot.at(qty - 1).setisadd(false);			//устанавливаем флаг добавления на false
		snackslot.pop_back();							//достаем из машины
	}
}

int VendingMachine::getEmptySlotsCount()				//функция из задания, возвращает количество свободных слотов
{
	int count = 0;										//добавляем переменную, которую будем возвращать	
	for (int i = 0; i < qty; i++)						//пробегаем циклом по всем слотам
	{
		if (snackslot.at(i).getisadd() == false)		//проверяем, по флагу, загружен ли слот в машину	
		{
			count++;									//если слот загружен, увеличиваем переменную
		}
	}
	return count;										//возвращаем результат
}



void VendingMachine::showGoods()						//функция, для отображения отображения всех ячеек в машине
{
	for (int i = 0; i < qty; i++)					//пробегаем циклом по всем местам под слот
	{
		if (snackslot.at(i).getisadd() != true)		//проверяем, вставлен ли слот, если нет, ты провариваемся сюда	
		{
			cout << endl  << "Ячейка для слотов номер: " << i + 1 << " - Слот отсутствует";
		}
		else                                        //если слот вставлен в машину то проваливаемся сюда
		{
			cout << endl << "Ячейка для слотов номер: " << i + 1 << " - ";
			snackslot.at(i).showSlot();				//дергаем функцию, которая печатает содержимое слота
		}
	}

}





